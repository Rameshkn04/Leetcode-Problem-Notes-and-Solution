ğŸ“˜ 1895. Largest Magic Square
ğŸ” Problem Statement

Given an m Ã— n integer matrix grid, return the largest integer k such that there exists a k Ã— k magic square inside the grid.

A magic square is defined as:

The sum of every row is equal

The sum of every column is equal

The sum of both main diagonals is equal

ğŸ§  Key Observations

Every 1 Ã— 1 square is trivially a magic square.

Maximum possible size of magic square is min(m, n).

Brute force checking every square is inefficient â†’ needs optimization.

âš™ï¸ Optimized Strategy
1ï¸âƒ£ Prefix Sum Technique

Use row-wise and column-wise prefix sums.

Enables O(1) computation of any row or column sum.

2ï¸âƒ£ Square Size Reduction

Start checking from largest possible size â†’ smallest.

Once a valid magic square is found, return immediately.

ğŸ”„ Algorithm Steps

Compute prefix sums for all rows and columns.

For k = min(m, n) down to 2:

Slide a k Ã— k window over the grid.

Use the first row as the target sum.

Check:

All row sums

All column sums

Both diagonals

If no square of size â‰¥ 2 exists, return 1.

â±ï¸ Complexity Analysis
Type	Complexity
Time	O(min(m,n) Ã— m Ã— n)
Space	O(m Ã— n)
ğŸ§ª Example

Input:

grid = [
  [7,1,4,5,6],
  [2,5,1,6,4],
  [1,5,4,3,2],
  [1,2,7,3,4]
]


Output:

3

ğŸ§© Python Implementation
class Solution:
    def largestMagicSquare(self, grid):
        m, n = len(grid), len(grid[0])
        
        row_ps = [[0] * (n + 1) for _ in range(m)]
        col_ps = [[0] * n for _ in range(m + 1)]
        
        for i in range(m):
            for j in range(n):
                row_ps[i][j + 1] = row_ps[i][j] + grid[i][j]
                col_ps[i + 1][j] = col_ps[i][j] + grid[i][j]
        
        def row_sum(r, c1, c2):
            return row_ps[r][c2] - row_ps[r][c1]
        
        def col_sum(c, r1, r2):
            return col_ps[r2][c] - col_ps[r1][c]
        
        for k in range(min(m, n), 1, -1):
            for i in range(m - k + 1):
                for j in range(n - k + 1):
                    target = row_sum(i, j, j + k)
                    valid = True
                    
                    for r in range(i, i + k):
                        if row_sum(r, j, j + k) != target:
                            valid = False
                            break
                    
                    if valid:
                        for c in range(j, j + k):
                            if col_sum(c, i, i + k) != target:
                                valid = False
                                break
                    
                    if valid:
                        d1 = sum(grid[i + x][j + x] for x in range(k))
                        d2 = sum(grid[i + x][j + k - 1 - x] for x in range(k))
                        if d1 != target or d2 != target:
                            valid = False
                    
                    if valid:
                        return k
        
        return 1

ğŸ Final Takeaway

Prefix sums are essential for efficiency.

Always check larger squares first to reduce computation.

Clean combination of sliding window + prefix sum.

â­ Difficulty: Medium
ğŸ“š Topic: Prefix Sum, Matrix, Simulation
ğŸ”— Platform: LeetCode
