# 1292. Maximum Side Length of a Square with Sum ‚â§ Threshold

## üìå Problem Statement

You are given a 2D matrix `mat` of size `m √ó n` and an integer `threshold`.

Return the **maximum side length** of a square submatrix such that the **sum of all its elements is less than or equal to `threshold`**.

---

## üß† Key Observations

- Brute force checking of all square submatrices is inefficient.
- We need a way to:
  - Quickly compute the sum of any square submatrix
  - Efficiently search for the maximum possible square size

---

## üí° Approach Used

### 1Ô∏è‚É£ Prefix Sum (2D)

We build a prefix sum matrix to compute the sum of any submatrix in **O(1)** time.

**Prefix Sum Formula:**

prefix[i][j] =
mat[i-1][j-1]

prefix[i-1][j]

prefix[i][j-1]

prefix[i-1][j-1]


---

### 2Ô∏è‚É£ Binary Search on Side Length

- The maximum possible square size is `min(m, n)`
- We binary search the answer:
  - If a square of size `k` exists with sum ‚â§ threshold ‚Üí try larger
  - Otherwise ‚Üí try smaller

---

## üîé Submatrix Sum Calculation

To get the sum of a `k √ó k` square ending at `(i, j)`:

sum =
prefix[i][j]

prefix[i-k][j]

prefix[i][j-k]

prefix[i-k][j-k]


---

## üß™ Example

### Input


mat = [[1,1,3,2,4,3,2],
[1,1,3,2,4,3,2],
[1,1,3,2,4,3,2]]
threshold = 4


### Output


2


‚úî A `2 √ó 2` square satisfies the condition  
‚ùå No `3 √ó 3` square has sum ‚â§ threshold

---

## üßë‚Äçüíª Python Implementation

```python
class Solution:
    def maxSideLength(self, mat, threshold):
        m, n = len(mat), len(mat[0])

        # Prefix sum matrix
        prefix = [[0] * (n + 1) for _ in range(m + 1)]

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                prefix[i][j] = (
                    mat[i - 1][j - 1]
                    + prefix[i - 1][j]
                    + prefix[i][j - 1]
                    - prefix[i - 1][j - 1]
                )

        def can(k):
            for i in range(k, m + 1):
                for j in range(k, n + 1):
                    total = (
                        prefix[i][j]
                        - prefix[i - k][j]
                        - prefix[i][j - k]
                        + prefix[i - k][j - k]
                    )
                    if total <= threshold:
                        return True
            return False

        low, high, ans = 0, min(m, n), 0

        while low <= high:
            mid = (low + high) // 2
            if can(mid):
                ans = mid
                low = mid + 1
            else:
                high = mid - 1

        return ans

‚è±Ô∏è Complexity Analysis
Component	Complexity
Prefix Sum Construction	O(m √ó n)
Binary Search	O(log(min(m, n)))
Square Validation	O(m √ó n)
Total Time	O(m √ó n √ó log(min(m, n)))
Space Complexity	O(m √ó n)
üéØ Interview Takeaways

Efficient use of 2D prefix sums

Binary search applied on answer space

Avoids brute force

Clean and scalable solution

‚úÖ Tags

Prefix Sum

Binary Search

Matrix

Dynamic Programming
