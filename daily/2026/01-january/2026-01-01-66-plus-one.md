# 2026-01-01 — 66. Plus One

## Metadata
- Difficulty: Easy  
- Topics: Arrays, Math  
- Source: [LeetCode — Plus One](https://leetcode.com/problems/plus-one/)  
- Date: 2026-01-01

## Problem
Given a non-empty array of decimal digits representing a non-negative integer, increment the integer by one and return the resulting digits as an array. The most significant digit is at index 0.

Example:
- Input: [1, 2, 3] → Output: [1, 2, 4]
- Input: [9, 9, 9] → Output: [1, 0, 0, 0]

## Constraints
- The array length n ≥ 1.
- Each element is an integer in the range 0–9.
- The integer represented by the digits may be large (do not convert to an integer if language limitations apply).

## Key Observations
- If the least significant digit (rightmost) is less than 9, incrementing it completes the operation with no carry.
- If a digit is 9, it becomes 0 and a carry of 1 must be added to the next more significant digit to the left.
- If all digits are 9, the result has one more digit: a leading 1 followed by zeros.

## Approach (Right-to-left carry propagation)
1. Iterate from the last index to the first.
2. If the current digit < 9:
   - Increment the digit and return the array immediately (no further carry).
3. If the current digit == 9:
   - Set it to 0 and continue the loop to propagate the carry.
4. If the loop finishes (all digits were 9), prepend 1 to the array and return.

This approach mimics manual addition and performs the operation in-place when possible.

## Algorithm (Pseudocode)
- For i from n-1 down to 0:
  - If digits[i] < 9: digits[i] += 1; return digits
  - Else: digits[i] = 0
- Return [1] + digits

## Complexity
- Time: O(n) — each digit is visited at most once.
- Space: O(1) extra space (excluding the output). In the worst case the output grows by one digit (when all digits are 9).

## Python Implementation
```python
from typing import List

class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        """
        Increment the integer represented by `digits` by one and return the resulting digits.
        Operates in-place when possible; handles carry propagation from right to left.
        """
        for i in range(len(digits) - 1, -1, -1):
            if digits[i] < 9:
                digits[i] += 1
                return digits
            digits[i] = 0

        # All digits were 9 — result is a 1 followed by zeros
        return [1] + digits
```

## Examples and Edge Cases
- Single digit no carry: [5] → [6]
- Single digit carry: [9] → [1, 0]
- Trailing 9s: [1, 2, 9, 9] → [1, 3, 0, 0]
- All 9s: [9, 9, 9] → [1, 0, 0, 0]

## Notes / Takeaways
- Processing from least significant to most significant digit (right-to-left) simplifies carry handling.
- Avoid converting the entire list to an integer when the integer size could exceed language limits — digit-wise arithmetic is safer and more general.
- This pattern (propagating carry/backtracking from the end) recurs in many elementary arithmetic array problems; the same idea can be adapted for subtraction, multiplication by small constants, and base-k arithmetic.
